import{a as m}from"./DragDropList-07635705.js";class p{constructor(i,e,s,t){this.direction=m.Horizontal,this.id=i,this.priority=s,this.count=e,this.itemSize=t,this.items=new Array(e),this.el=void 0,this.ro=new ResizeObserver(this.onResize.bind(this)),this.containerClass="horizontal center"}scrollContainer(i,e){const{el:s}=this,t=s.getBoundingClientRect(),r=t.width/3;if(i>t.left&&i<t.left+r){const n=(i-t.left)/r*10;s.scrollLeft-=10-n}else if(i<t.right&&i>t.right-r){const n=(t.right-i)/r*10;s.scrollLeft+=10-n}}onResize(i){const e=i[0].contentRect.width;this.elWidth=e}placeholderStyleStr(){return`width: ${this.itemSize}px; height: 100%;`}pointIndex(i,e){const{el:s,itemSize:t,count:r}=this,n=s.getBoundingClientRect(),o=n.left-s.scrollLeft+window.scrollX;n.top-s.scrollTop+window.scrollY,i=i-o;const l=this.count*this.itemSize;let c=0;l<this.elWidth&&(c=Math.floor((this.elWidth-l)/2));const a=Math.floor((i-c)/t);return Math.min(Math.max(a,0),r)}dragYOffset(i,e){return this.el.getBoundingClientRect().top}dragXOffset(i,e){const s=this.el.getBoundingClientRect(),t=(e!=null?e:this.count)*this.itemSize;if(t<this.elWidth){const r=(this.elWidth-t)/2;return i*this.itemSize+r+s.left}return i*this.itemSize+s.left-this.el.scrollLeft}itemHeight(){return this.el.clientHeight}itemWidth(){return this.itemSize}styleSourceMove(i,e,s){const{items:t,itemSize:r}=this;for(let n=0;n<t.length;++n){const o=i>e&&(n<e||n>e&&n<=i)||i<e&&n<i||i==e&&n<e,l=i>e&&n>i||i<e&&(n>=i&&n<e||n>e)||i==e&&n>e,c=t[n];o?c&&(c.style.cssText=`transform: translateX(0px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${r}px;`):l&&(s?c&&(c.style.cssText=`transform: translateX(${r}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${r}px;`):c&&(c.style.cssText=`transform: translateX(${r}px); width: ${r}px;`))}}styleSourceMissing(i){const{count:e,itemSize:s,items:t,elWidth:r}=this;if(e*s>r&&(e-1)*s<r){const n=Math.floor((r-(e-1)*s)/2)-1;for(let o=0;o<e;++o)t[o]&&o!==i&&(t[o].style.cssText=`transform: translateX(${n}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${s}px;`)}else if((e-1)*s<r)for(let n=0;n<e;++n)t[n]&&n!==i&&(t[n].style.cssText=`transform: translateX(${s/2}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${s}px;`);else for(let n=0;n<e;++n)t[n]&&n!==i&&(t[n].style.cssText=`transform: translateX(0px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${s}px;`)}styleDestMove(i){const{items:e,count:s,itemSize:t,elWidth:r,el:n}=this;if((e.length+1)*t>r&&(n.style.cssText=`transition: padding-bottom 0.2s cubic-bezier(0.2, 0, 0, 1); padding-right: ${t}px;`),s*t<r&&(s+1)*t>r){const o=r-s*t,l=Math.floor(o/2)-1,c=t-l;for(let a=0;a<s;++a){const h=e[a];a<i?h&&(h.style.cssText=`transform: translateX(-${l}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`):h&&(h.style.cssText=`transform: translateX(${c}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`)}}else if(s*t<r)for(let o=0;o<s;++o){const l=e[o];o<i?l&&(l.style.cssText=`transform: translateX(-${t/2}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`):l&&(l.style.cssText=`transform: translateX(${t/2}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`)}else for(let o=0;o<s;++o){const l=e[o];o<i?l&&(l.style.cssText=`transform: translateX(0px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`):l&&(l.style.cssText=`transform: translateX(${t}px); transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${t}px;`)}}styleDestReset(){const{items:i,itemSize:e,el:s}=this;s.style.cssText="transition: padding-bottom 0.2s cubic-bezier(0.2, 0, 0, 1); padding-bottom: 0px;";for(let t=0;t<i.length;++t)i[t]&&(i[t].style.cssText=`transform:translateX(0px); transition:transform 0.2s cubic-bezier(0.2, 0, 0, 1); width: ${e}px;`)}styleRemove(){const{items:i,itemSize:e}=this;for(let s=0;s<i.length;++s){const t=i[s];t&&(t.style.cssText=`width: ${e}px;`)}}styleContainerBaseStyle(){this.ro.observe(this.el),this.elWidth=this.el.clientWidth,this.el.style.cssText="";const{items:i,itemSize:e}=this;for(let s=0;s<i.length;++s){const t=i[s];t&&(t.style.cssText=`width: ${e}px;`)}}}export{p as H};
